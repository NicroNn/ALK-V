# Спецификация языка программирования "ALK-V" (Working Title)

## 1. Обзор языка

ALK-V - статически типизированный язык программирования с автоматическим управлением памятью, разработанный для исполнения на виртуальной машине с JIT-компиляцией.

**Ключевые особенности:**
- Статическая типизация с выводом типов в некоторых случаях
- Объектно-ориентированная модель с классами
- Автоматическое управление памятью (GC)
- Поддержка функциональных элементов (рекурсия, функции первого класса)
- Безопасность памяти и контроль доступа

## 2. Синтаксис и основные конструкции

### 2.1 Объявление переменных
```ALK-V
переменная : тип = значение;
// Примеры:
x : int = 10;
имя : string = "Stark";
массив : int[] = [1, 2, 3];
```

### 2.2 Функции
```ALK-V
fnc имя_функции : возвращаемый_тип (параметры) {
    // тело функции
}

// Пример:
fnc factorial : int (n : int) {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}
```

### 2.3 Классы и методы
```ALK-V
class ИмяКласса {
public:
    поле : тип;
    
    method : тип_возврата (параметры) {
        // реализация
    }
    
    Конструктор(параметры) {
        // инициализация
    }

private:
    приватное_поле : тип;
}

// Пример из вашего кода:
class Shtuka {
public:
    hihihoho : int;
    
    method : int(n : int) {
        // реализация метода
    }

    Shtuka(args) {
        // конструктор
    }

private:
    secret : bool;    
}
```

### 2.4 Управляющие конструкции

**Условия:**
```ALK-V
if (условие) {
    // код
} else if (другое_условие) {
    // код
} else {
    // код
}
```

**Циклы:**
```ALK-V
// While цикл
while (условие) {
    // код
}

// For цикл с диапазоном
for (i in начало...конец) {
    // код
}

// For цикл с условием
for (i : int = 0; i < n; i = i + 1) {
    // код
}
```

**Switch:**
```ALK-V
switch (выражение) {
    значение1 => действие1;
    значение2 => действие2;
    _ => действие_по_умолчанию;
}
```

## 3. Система типов

### 3.1 Базовые типы
- `int` - целые числа
- `float` - числа с плавающей точкой  
- `bool` - логический тип (`T`/`F`)
- `string` - строки
- `type[]` - массивы
- `void` - отсутствие значения

### 3.2 Составные типы
- **Классы** - пользовательские типы данных
- **Массивы** - гомогенные коллекции
- **Maybe-типы** (планируется) для обработки отсутствующих значений

## 4. Стандартная библиотека "Ochev"

Библиотека для базовых операций ввода-вывода и утилит:

```ALK-V
// Операции с массивами
Ochev.tudaSyuda(arr[i], arr[j])  // обмен элементов
Ochev.печать(значение)           // вывод

// Работа с битами
Ochev.mask(number : int, mask : int)

// Математические функции
Ochev.макс(a, b)
Ochev.мин(a, b)
```

## 5. Операторы

### 5.1 Арифметические
- `+`, `-`, `*`, `/`, `%`

### 5.2 Сравнения  
- `==`, `!=`, `<`, `>`, `<=`, `>=`
- `=?` (специальный оператор сравнения - требуется уточнение семантики)

### 5.3 Логические
- `&&` (И), `||` (ИЛИ), `!` (НЕ)

## 6. Архитектура исполнения

### 6.1 Виртуальная машина StarkVM
- **Байткод** - компактное промежуточное представление
- **Стек исполнения** - для вызовов функций и арифметики
- **Куча** - для динамических данных и объектов

### 6.2 Менеджер памяти
- **Автоматический GC** (Mark-and-Sweep + Generational)
- **Сборка мусора** с паузами < 10ms
- **Оптимизация аллокаций** для массивов

### 6.3 JIT-компилятор
- **Теплые пути** - компиляция при повторных вызовах
- **Инлайнинг** маленьких функций
- **Специализация** для часто используемых типов

## 7. Примеры реализации benchmark'ов

### 7.1 Факториал (рекурсивный)
```ALK-V
fnc factorial : int (n : int) {
    if (n == 0) {
        return 1;
    }
    return n * factorial(n - 1);
}

// Бенчмарк
main : void () {
    start : int = Ochev.время();
    результат : int = factorial(20);
    end : int = Ochev.время();
    Ochev.печать("Factorial 20: " + результат);
    Ochev.печать("Time: " + (end - start) + "ms");
}
```

### 7.2 Сортировка пузырьком
```ALK-V
fnc bubbleSort : void (arr : int[], size : int) {
    sorted : bool = F;
    while (!sorted) {
        sorted = T;
        for (i in 1...size-1) {
            if (arr[i] < arr[i-1]) {
                sorted = F;
                Ochev.tudaSyuda(arr[i], arr[i-1]);
            }
        }
    }
}
```

### 7.3 Решето Эратосфена
```ALK-V
fnc sieve : bool[] (n : int) {
    primes : bool[] = new bool[n];
    
    // Инициализация
    for (i in 0...n-1) {
        primes[i] = T;
    }
    
    // Алгоритм
    for (i in 2...n-1) {
        if (primes[i]) {
            j : int = i * i;
            while (j < n) {
                primes[j] = F;
                j = j + i;
            }
        }
    }
    return primes;
}
```

## 8. План разработки

### Этап 1: Ядро языка
- [ ] Лексический анализатор
- [ ] Парсер AST
- [ ] Базовая система типов

### Этап 2: Виртуальная машина  
- [ ] Байткод спецификация
- [ ] Интерпретатор
- [ ] Система управления памятью

### Этап 3: Оптимизации
- [ ] JIT-компиляция
- [ ] Оптимизации GC
- [ ] Стандартная библиотека
